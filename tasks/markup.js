'use strict';

const rootPath = process.cwd(),
        concat = require('gulp-concat-util'),
        fs = require('fs'),
        gulp = require('gulp'),
        gulpfile = require(`${rootPath}/gulpfile.js`),
        gutil = require('gulp-util'),
        markupConfig = gulpfile.config.markup,
        markupTasks = markupConfig.tasks,
        nunjucksRender = require('gulp-nunjucks-render'),
        concatMacrosTaskPrefix = markupConfig.concatMacrosTaskPrefix,
        buildTaskPrefix = markupConfig.buildTaskPrefix,
        concatTasks = markupTasks.filter(task => task.componentMacros).map(task => `${concatMacrosTaskPrefix}${task.name}`),
        buildTasks = markupTasks.filter(task => task.docSourceFilePaths).map(task => `${buildTaskPrefix}${task.name}`);

function generateMacroConcatenateTask(c) {
    if (c.componentMacros) {
        gulp.task(`${concatMacrosTaskPrefix}${c.name}`, function(){
            return gulp.src([c.componentMacros, `!${c.componentMacroOutputPath}/${c.componentMacroFilename}`])
                .pipe(concat(c.componentMacroFilename))
                .pipe(concat.header('{# DO NOT EDIT: This file is automatically generated by the project\'s build task #}\n'))
                .pipe(gulp.dest(c.componentMacroOutputPath));
        });
    }
}

function generateBuildTask(c) {
    if (c.docSourceFilePaths) {
        let nunjucksOptions = {
                data: {},
                envOptions: {
                    watch: false
                },
                manageEnv: function(env) {
                    // projectNodePackage.addDocLibraryNunjucksFilters(env);
                },
                path: c.docTemplateRootPaths
            };

        if (c.docDataFile && fs.existsSync(c.docDataFile)) {
            let file = fs.readFileSync(c.docDataFile, {encoding: 'UTF-8'}),
                data = {};

            try {
                data = JSON.parse(file);
            } catch (e) {
                console.log(e, `Warning: Could not parse ${c.docDataFile} into JSON for nunjucks`);
            }

            nunjucksOptions.data = data;
        }

        // Compile doc src to html
        gulp.task(`${buildTaskPrefix}${c.name}`, function() {
            return gulp.src(c.docSourceFilePaths)
                .pipe(
                    nunjucksRender(nunjucksOptions).on('error', function(e){
                        gutil.log(e);
                        gutil.beep();
                        this.emit('end');
                    })
                )
                .pipe(gulp.dest(c.docOutputPath));
        });
    }
}

markupTasks.forEach(function(c){
    generateMacroConcatenateTask(c);
    generateBuildTask(c);
});

// Concatenate all macro files
gulp.task(`${concatMacrosTaskPrefix}all`, gulp.parallel(concatTasks));

// Build all doc files
gulp.task(`${buildTaskPrefix}all`, gulp.parallel(buildTasks));
