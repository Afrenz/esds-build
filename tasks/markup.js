'use strict';

const config = require('./config.js'),
        concat = require('gulp-concat-util'),
        fs = require('fs'),
        path = require('path'),
        gulp = require('gulp'),
        gutil = require('gulp-util'),
        marked = require('marked'),
        stripIndent = require('strip-indent'),
        buildConfig = config.get(),
        markupConfig = buildConfig.markup,
        markupTasks = markupConfig.tasks,
        nunjucksRender = require('gulp-nunjucks-render'),
        concatMacrosTaskPrefix = markupConfig.concatMacrosTaskPrefix,
        buildTaskPrefix = markupConfig.buildTaskPrefix,
        watchTaskPrefix = markupConfig.watchTaskPrefix,
        watchDocsTaskPrefix = markupConfig.watchDocsTaskPrefix,
        watchMacrosTaskPrefix = markupConfig.watchMacrosTaskPrefix,
        concatTasks = markupTasks.filter(task => task.componentMacros).map(task => `${concatMacrosTaskPrefix}${task.name}`),
        buildTasks = markupTasks.filter(task => task.docSourceFilePaths).map(task => `${buildTaskPrefix}${task.name}`),
        watchDocsTasks = markupTasks.filter(task => task.docSourceFilePaths).map(task => `${watchDocsTaskPrefix}${task.name}`),
        watchMacrosTasks = markupTasks.filter(task => task.componentMacros).map(task => `${watchMacrosTaskPrefix}${task.name}`);

function addDocLibraryNunjucksFilters(env) {
    // env.addFilter('htmlbeautify', function(string) {
    //     return htmlBeautify(string, htmlBeautifyOptions);
    // });

    // env.addFilter('cssbeautify', function(string) {
    //     return cssBeautify(string, cssBeautifyOptions);
    // });

    // env.addFilter('stripindent', function(string){
    //     return stripIndent(string);
    // });

    env.addFilter('markdown', function(string, wrap, wrapper_class) {
        var rendered_markup = marked(stripIndent(string));
        wrap = typeof wrap === 'undefined' ? false : wrap;
        wrapper_class = typeof wrapper_class === 'undefined' ? 'esds-markdown-wrap' : wrapper_class;

        if (wrap) {
            rendered_markup = '<div class="' + wrapper_class + '">' + rendered_markup + "</div>";
        }

        return env.filters.safe(rendered_markup);
    });

    // env.addFilter('nunjucksrenderstring', function(string, context){
    //     return env.renderString(string, context);
    // });

    // env.addFilter('getcontext', function(){
    //     return this.ctx;
    // });

    // env.addGlobal('getContext', function(name) {
    //     return name ? this.ctx[name] : this.ctx;
    // });
}

function generateMacroConcatenateTask(c) {
    if (c.componentMacros) {
        gulp.task(`${concatMacrosTaskPrefix}${c.name}`, function(){
            const concatenatedMacroFilename = `${buildConfig.codeNamespace}${buildConfig.markupSourceExtension}`;
            return gulp.src([c.componentMacros, `!${c.componentMacroOutputPath}/${c.componentMacroFilename}`])
                .pipe(concat(concatenatedMacroFilename))
                .pipe(concat.header('{# DO NOT EDIT: This file is automatically generated by the project\'s build task #}\n'))
                .pipe(gulp.dest(c.componentMacroOutputPath));
        });
    }
}

function generateWatchMacrosTask(c) {
    if (c.componentMacros) {
        gulp.task(`${watchMacrosTaskPrefix}${c.name}`, function(){
            const concatTask = `${concatMacrosTaskPrefix}${c.name}`,
                    concatenatedMacroFilename = `${c.componentMacroOutputPath}/${c.componentMacroFilename}`,
                    macroLibraryHasDocs = c.docSourceFilePaths,
                    macroLibraryIsReferenced = c.componentsReferencedBy;

            let postConcatBuildTasks = [];

            if (macroLibraryIsReferenced) {
                let referencedBuildTasks = c.componentsReferencedBy.map(taskName => `${markupConfig.buildTaskPrefix}${taskName}`);
                postConcatBuildTasks = postConcatBuildTasks.concat(referencedBuildTasks);
            }

            if (macroLibraryHasDocs) {
                let macroLibraryBuildTask = `${markupConfig.buildTaskPrefix}${c.name}`;
                postConcatBuildTasks.push(macroLibraryBuildTask);
            }

            return gulp.watch([c.componentMacros, `!${concatenatedMacroFilename}`], gulp.series(concatTask, gulp.parallel(postConcatBuildTasks)));
        });
    }
}

function generateWatchDocsTask(c) {
    if (c.docSourceFilePaths) {
        gulp.task(`${watchDocsTaskPrefix}${c.name}`, function(){
            return gulp.watch(c.docTemplateWatchPaths, gulp.series(`${buildTaskPrefix}${c.name}`));
        });
    }
}



function getDataForTemplates() {
    const fullDataPath = path.join(buildConfig.rootPath, buildConfig.dataPath);
    let allDataFiles = ['tokens.json'],
        data = {};

    if (fs.existsSync(fullDataPath)) {
        allDataFiles = allDataFiles.concat(fs.readdirSync(fullDataPath));
    }
    allDataFiles.forEach(f => {
        if (f.indexOf('.json') !== -1) {
            let namespace = f.replace(/.json/, ''),
                dataDirectory = f === 'tokens.json' ? buildConfig.tokensPath : buildConfig.dataPath,
                fullFilepath = path.join(buildConfig.rootPath, dataDirectory, f);
            if (fs.existsSync(fullFilepath)) {
                let contents = fs.readFileSync(fullFilepath, {encoding: 'UTF-8'}),
                    json;

                try {
                    json = JSON.parse(contents);
                    if (namespace === 'tokens') {
                        Object.assign(data, json);
                    } else {
                        data[namespace] = json;
                    }
                } catch (e) {
                    // eslint-disable-next-line no-console
                    console.log(e, `Warning: Could not parse data file ${fullFilepath} into JSON for nunjucks`);
                }
            }
        }
    });

    return data;
}

function generateBuildTask(t) {
    if (t.docSourceFilePaths) {
        let nunjucksOptions = {
            data: getDataForTemplates(),
            envOptions: {
                watch: false
            },
            manageEnv: function(env) {
                addDocLibraryNunjucksFilters(env);
                if (buildConfig.manageNunjucksEnv) {
                    buildConfig.manageNunjucksEnv(env);
                }
            },
            path: t.docTemplateImportPaths
        };

        // Compile doc src to html
        gulp.task(`${buildTaskPrefix}${t.name}`, function() {
            return gulp.src(t.docSourceFilePaths)
                .pipe(
                    nunjucksRender(nunjucksOptions).on('error', function(e){
                        gutil.log(e);
                        gutil.beep();
                        this.emit('end');
                    })
                )
                .pipe(gulp.dest(t.docOutputPath));
        });
    }
}

markupTasks.forEach(function(c){
    generateMacroConcatenateTask(c);
    generateBuildTask(c);
    generateWatchMacrosTask(c);
    generateWatchDocsTask(c);
});

// Concatenate all macro files
gulp.task(`${concatMacrosTaskPrefix}all`, gulp.parallel(concatTasks));

// Build all doc files
gulp.task(`${buildTaskPrefix}all`, gulp.parallel(buildTasks));

// Watch all macro files
gulp.task(`${watchMacrosTaskPrefix}all`, gulp.parallel(watchMacrosTasks));

// Watch all doc files
gulp.task(`${watchDocsTaskPrefix}all`, gulp.parallel(watchDocsTasks));

gulp.task(`${watchTaskPrefix}all`, gulp.parallel(`${watchMacrosTaskPrefix}all`, `${watchDocsTaskPrefix}all`));

